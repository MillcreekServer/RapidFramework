package io.github.wysohn.rapidframework3.utils.sql;

import com.mysql.cj.jdbc.MysqlConnectionPoolDataSource;
import io.github.wysohn.rapidframework3.utils.MiniConnectionPoolManager;
import io.github.wysohn.rapidframework3.utils.Validation;
import org.sqlite.javax.SQLiteConnectionPoolDataSource;

import javax.sql.ConnectionPoolDataSource;
import java.io.File;
import java.sql.*;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.function.Consumer;
import java.util.function.Function;

public class SQLSession {
    private final MiniConnectionPoolManager pool;
    private Connection connection;
    private boolean autoCommit;

    private SQLSession(ConnectionPoolDataSource ds) throws SQLException {
        this.pool = new MiniConnectionPoolManager(ds, 4);
        reconnect();
    }

    private void reconnect() throws SQLException {
        connection = pool.getConnection();
        connection.setAutoCommit(autoCommit);
    }

    public void execute(String sql, Consumer<PreparedStatement> fn, Consumer<Long> fnResult) {
        execute(sql, fn, fnResult, Statement.RETURN_GENERATED_KEYS);
    }

    public void execute(String sql, Consumer<PreparedStatement> fn, Consumer<Long> fnResult, int autoGeneratedKeys) {
        try (PreparedStatement stmt = connection.prepareStatement(sql, autoGeneratedKeys)) {
            fn.accept(stmt);
            long result = stmt.executeUpdate();
            if (result < 1) {
                fnResult.accept(0L);
                return;
            }

            try (ResultSet rs = stmt.getGeneratedKeys()) {
                if (rs.next())
                    fnResult.accept(rs.getLong(1));
                else
                    fnResult.accept(result);
            } catch (SQLException ex) {
                ex.printStackTrace();
            }
        } catch (SQLException ex) {
            if (ex.getSQLState() == null) {
                ex.printStackTrace();
                return;
            }

            switch (ex.getSQLState()) {
                case "08003":
                case "08006":
                    try {
                        reconnect();
                        execute(sql, fn, fnResult);
                    } catch (SQLException ex2) {
                        ex2.printStackTrace();
                    }
                    break;
                default:
                    ex.printStackTrace();
            }
        }
    }

    public void execute(String sql) throws SQLException {
        execute(sql, pstmt -> {
        }, id -> {
        });
    }

    public void commit() throws SQLException {
        if (!autoCommit)
            connection.commit();
    }

    public void rollback() throws SQLException {
        if (!autoCommit)
            connection.rollback();
    }

    public Savepoint saveState() throws SQLException {
        if (autoCommit)
            throw new RuntimeException("autoCommit is on");

        return connection.setSavepoint();
    }

    public void restoreState(Savepoint state) throws SQLException {
        if (autoCommit)
            throw new RuntimeException("autoCommit is on");

        connection.rollback(state);
    }

    public <T> List<T> query(String sql, Consumer<PreparedStatement> fn, Function<ResultSet, T> evalFn) {
        try (PreparedStatement stmt = connection.prepareStatement(sql)) {
            fn.accept(stmt);

            List<T> list = new ArrayList<>();
            try (ResultSet rs = stmt.executeQuery()) {
                while (rs.next()) {
                    T val = evalFn.apply(rs);
                    if (val != null)
                        list.add(val);
                }
            }

            return list;
        } catch (SQLException ex) {
            if (ex.getSQLState() == null) {
                ex.printStackTrace();
                return null;
            }

            try {
                switch (ex.getSQLState()) {
                    case "08003":
                    case "08006":
                        reconnect();
                        return query(sql, fn, evalFn);
                    default:
                        ex.printStackTrace();
                        break;
                }
            } catch (SQLException ex2) {
                ex2.printStackTrace();
            }
        }

        return null;
    }

    public void close() throws SQLException {
        this.connection.close();
    }

    public static class Builder {
        private static final Function<Attribute, String> COMMON_CONVERTER = attribute -> {
            switch (attribute) {
                case NOT_NULL:
                    return "NOT NULL";
                case PRIMARY_KEY:
                case KEY:
                    return ""; // set this in constraint
                default:
                    throw new RuntimeException("Undefined attribute " + attribute);
            }
        };

        private final ConnectionPoolDataSource ds;
        private final Function<Attribute, String> converter;
        private final List<TableInitializer> tableInitializers = new LinkedList<>();

        private boolean autoCommit = false;

        private Builder(ConnectionPoolDataSource ds,
                        Function<Attribute, String> converter) {
            this.ds = ds;
            this.converter = converter;
        }

        public static Builder sqlite(File dbFile) {
            try {
                Class.forName("org.sqlite.JDBC");
            } catch (ClassNotFoundException e) {
                e.printStackTrace();
            }

            return new Builder(createDataSource(dbFile), attribute -> {
                switch (attribute) {
                    case PRIMARY_KEY:
                        return "PRIMARY KEY";
                    case AUTO_INCREMENT:
                        return "AUTOINCREMENT";
                    default:
                        return COMMON_CONVERTER.apply(attribute);
                }
            });
        }

        public static Builder mysql(String host, String databaseName, String user, String password)
                throws SQLException {
            return new Builder(createDataSource(host, databaseName, user, password), attribute -> {
                switch (attribute) {
                    case AUTO_INCREMENT:
                        return "AUTO_INCREMENT";
                    default:
                        return COMMON_CONVERTER.apply(attribute);
                }
            });
        }

        /**
         * Enable auto commit for this session
         *
         * @return
         */
        public Builder autoCommit() {
            this.autoCommit = true;
            return this;
        }

        /**
         * Create a new table.
         * <p>
         * If the table already exist, missing columns will be scanned, and the table will be
         * altered to add new fields. To remove the column, it must be done manually.
         * <p>
         * The information provided in the TableInitializer consumer will also be used
         * to create a newly added field if the field doesn't exist. However, if newly added
         * field has constraints, such as UNIQUE, depending on the using database, it may not work.
         * <p>
         * For example, SQLite doesn't allow ALTER TABLE ? ADD to add constraint. It is allowed only
         * when the table is newly created.
         *
         * @param tableName
         * @param consumer
         * @return
         */
        public Builder createTable(String tableName, Consumer<TableInitializer> consumer) {
            TableInitializer initializer = new TableInitializer(tableName);
            consumer.accept(initializer);
            tableInitializers.add(initializer);
            return this;
        }

        public SQLSession build() throws SQLException {
            SQLSession sqlSession = new SQLSession(ds);
            sqlSession.autoCommit = autoCommit;
            tableInitializers.forEach(initializer -> {
                initializer.createTable(sqlSession.connection);
                initializer.addMissingFields(sqlSession.connection);
            });
            return sqlSession;
        }

        public class TableInitializer {
            private final String tableName;

            private boolean ifNotExist;
            private final List<String> fields = new LinkedList<>();
            private final List<String> keys = new LinkedList<>();
            private final List<String> uniques = new LinkedList<>();

            public TableInitializer(String tableName) {
                this.tableName = tableName;
            }

            public TableInitializer ifNotExist() {
                this.ifNotExist = true;
                return this;
            }

            public TableInitializer field(String fieldName, String type, Attribute... others) {
                boolean key = false;
                boolean unique = false;

                List<String> modifiers = new ArrayList<>();
                for (Attribute attribute : others) {
                    if (attribute == Attribute.KEY || attribute == Attribute.PRIMARY_KEY) {
                        String converted = converter.apply(attribute);
                        if (converted.length() > 0) {
                            // sqlite require PRIMARY KEY before AUTO INCREMENT
                            modifiers.add(converted);
                        } else {
                            key = true;
                        }
                    } else if (attribute == Attribute.UNIQUE) {
                        unique = true;
                    } else {
                        modifiers.add(converter.apply(attribute));
                    }
                }

                field(fieldName + " " + type + " " + String.join(" ", modifiers));
                if (key)
                    keys.add(fieldName);
                if (unique)
                    uniques.add(fieldName);
                return this;
            }

            public TableInitializer field(String plainText) {
                fields.add(plainText);
                return this;
            }

            private void createTable(Connection conn) {
                Validation.validate(fields.size(), val -> val > 0, "at least one field is required.");

                String sql = "CREATE TABLE";
                if (ifNotExist)
                    sql += " IF NOT EXISTS";
                sql += " " + tableName + "(";
                sql += String.join(",", fields);
                if (keys.size() > 0)
                    sql += ",PRIMARY KEY(" + String.join(",", keys) + ")";
                if (uniques.size() > 0)
                    sql += ",UNIQUE(" + String.join(",", uniques) + ")";
                sql += ");";

                try (PreparedStatement newTableStmt = conn.prepareStatement(sql)) {
                    newTableStmt.executeUpdate();
                } catch (SQLException ex) {
                    ex.printStackTrace();
                }
            }

            private void addMissingFields(Connection conn) {
                try {
                    DatabaseMetaData metaData = conn.getMetaData();

                    for (String field : fields) {
                        String fieldName = field.split(" ")[0];
                        ResultSet rs = metaData.getColumns(null, null, tableName, fieldName);
                        if (rs.next())
                            continue;

                        PreparedStatement pstmt = conn.prepareStatement(String.format("ALTER TABLE %s ADD %s",
                                tableName,
                                field));
                        pstmt.execute();
                    }

                } catch (SQLException ex) {
                    ex.printStackTrace();
                }
            }
        }
    }

    public enum Attribute {
        AUTO_INCREMENT, NOT_NULL, PRIMARY_KEY, KEY, UNIQUE
    }

    public static SQLiteConnectionPoolDataSource createDataSource(File dbFile) {
        SQLiteConnectionPoolDataSource ds = new SQLiteConnectionPoolDataSource();
        ds.setUrl(String.format("jdbc:sqlite:%s", dbFile.getAbsolutePath()));
        ds.setEncoding("UTF-8");
        return ds;
    }

    public static MysqlConnectionPoolDataSource createDataSource(String address, String dbName, String userName,
                                                                 String password) throws SQLException {
        MysqlConnectionPoolDataSource ds = new MysqlConnectionPoolDataSource();
        ds.setURL("jdbc:mysql://" + address + "/" + dbName + "?autoReconnect=true");
        ds.setUser(userName);
        ds.setPassword(password);
        ds.setCharacterEncoding("UTF-8");
        ds.setAutoReconnectForPools(true);
        ds.setAutoReconnect(true);
        ds.setUseSSL(false);

        return ds;
    }
}
